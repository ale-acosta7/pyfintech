import matplotlib.pyplot as plt
import yfinance as yf
import pandas as pd
import numpy as np
from copy import deepcopy
from pandas.plotting import register_matplotlib_converters

register_matplotlib_converters()


# Lines 11-139 are functions that return a technical indicator in the form of a Series
def simple_moving_avg(df, length=20, src='Close'):
    # calculate simple moving average
    return df[src].rolling(window=length).mean()


def exp_moving_avg(df, length=20, src='Close'):
    # calculate exponential moving average
    return df[src].ewm(span=length, adjust=False).mean()


def volume_weighted_mov_avg(df, length=20, src='Close'):
    # volume times price
    vol_price = df[src] * df['Volume']
    # rolling weighted average
    return vol_price.rolling(window=length).sum() / df['Volume'].rolling(window=length).sum()


def rel_strength_index(df, length=14, src='Close'):
    # calculate Relative Strength Index (RSI)
    # find change from one tick to the next
    delta = df[src].diff()
    # create duplicates two duplicates of delta, and keep positive values in 'gain' and negative values in 'loss'
    gain, loss = delta.copy(), delta.copy()
    gain[gain < 0] = 0
    loss[loss >= 0] = 0
    # apply exponential moving average to gain and loss
    avg_gain = gain.ewm(span=length, adjust=False).mean()
    avg_loss = loss.abs().ewm(span=length, adjust=False).mean()

    rs = avg_gain / avg_loss
    final = 100.0 - (100.0 / (1.0 + rs))
    return final


def bollinger_bands(df, length=20, st_dev=2., offset=0, src='Close'):
    # calculate bollinger bands
    basis = simple_moving_avg(df, length=length)
    # find ROLLING standard deviation over specified length
    sd = df[src].rolling(window=length).std(ddof=0)

    basis = basis.shift(offset)
    upper_band = basis + (sd * st_dev)
    lower_band = basis - (sd * st_dev)

    bb = pd.DataFrame({'Basis': basis, 'Upper Band': upper_band, 'Lower Band': lower_band})
    return bb


def MACD(df, fast_length=12, slow_length=26, src='Close', smoothing=9, simple_oscillator=False, simple_signal=False):
    # calculate Moving Average Convergence / Divergence
    fast_ma = exp_moving_avg(df, length=fast_length, src=src)
    slow_ma = exp_moving_avg(df, length=slow_length, src=src)

    if simple_oscillator is True:
        fast_ma = simple_moving_avg(df, length=fast_length, src=src)
        slow_ma = simple_moving_avg(df, length=slow_length, src=src)

    macd = fast_ma - slow_ma
    signal = macd.ewm(span=smoothing, adjust=False).mean()

    if simple_signal is True:
        signal = macd.rolling(span=smoothing, adjust=False).mean()

    # Histogram of MACD - signal
    hist = macd - signal

    indicator = pd.DataFrame({'MACD': macd, 'Signal': signal, 'Hist': hist})
    return indicator


def hl2(df):
    # average of high and low
    return (df['High'] + df['Low']) / 2


def hlc3(df):
    # average of high, low, and close
    return (df['High'] + df['Low'] + df['Close']) / 3


def ohlc4(df):
    # average of high, low, close, and open
    return (df['High'] + df['Low'] + df['Close'] + df['Open']) / 4


def stochastic(df, period_k=14, period_d=3, smooth=3):
    # calculates stochastics
    low_low = df['Low'].rolling(window=period_k).min()
    high_high = df['High'].rolling(window=period_k).max()
    k = (((df['Close'] - low_low) * 100) / (high_high - low_low))
    k = k.rolling(window=smooth).mean()
    d = k.rolling(window=period_d).mean()
    stoch = pd.DataFrame({'%K': k, '%D': d})
    return stoch


def obv(df):
    OBV = [df.iloc[0]['Volume']]
    for i in range(1, len(df)):
        row = df.iloc[i]
        if row['Close'] > df.iloc[i - 1]['Close']:
            OBV.append(OBV[-1] + row['Volume'])
        elif row['Close'] < df.iloc[i - 1]['Close']:
            OBV.append(OBV[-1] - row['Volume'])
        else:
            OBV.append(OBV[-1])
    return pd.Series(OBV)


def cci(df, length=20):
    tp = (df['High'] + df['Low'] + df['Close']) / 3
    final = pd.Series((tp - tp.rolling(window=length).mean()) / (0.015 * tp.rolling(window=length).std()))
    return final


def ichimoku(df, conversion_period=9, base_period=26, lagging_periods=52, displ=26):
    def donchian(period):
        return (df['High'].rolling(window=period).max() + df['Low'].rolling(window=period).min()) / 2
    conversion_line = donchian(conversion_period)
    base_line = donchian(base_period)
    ls_a = ((conversion_line + base_line) / 2).shift(displ)
    ls_b = donchian(lagging_periods).shift(displ)
    lagging = df['Close'].shift(-1 * displ)
    ichi_cloud = pd.DataFrame({'Conversion Line': conversion_line, 'Base Line': base_line,
                              'Lead 1': ls_a, 'Lead 2': ls_b, 'Lagging': lagging})
    return ichi_cloud


def p_sar(df, accel=0.02, max_val=0.2):
    length = len(df)
    high = list(df['High'])
    low = list(df['Low'])
    close = list(df['Close'])
    psar = close[0:length]
    bull = True
    af = accel
    hp = high[0]
    lp = low[0]

    for i in range(1, length):
        if bull:
            psar[i] = psar[i - 1] + af * (hp - psar[i - 1])
        else:
            psar[i] = psar[i - 1] + af * (lp - psar[i - 1])

        reverse = False

        if bull:
            if low[i] < psar[i]:
                bull = False
                reverse = True
                psar[i] = hp
                lp = low[i]
                af = accel
        else:
            if high[i] > psar[i]:
                bull = True
                reverse = True
                psar[i] = lp
                hp = high[i]
                af = accel

        if not reverse:
            if bull:
                if high[i] > hp:
                    hp = high[i]
                    af = min(af + accel, max_val)
                if low[i - 1] < psar[i]:
                    psar[i] = low[i - 1]
                if low[i - 2] < psar[i]:
                    psar[i] = low[i - 2]
            else:
                if low[i] < lp:
                    lp = low[i]
                    af = min(af + accel, max_val)
                if high[i - 1] > psar[i]:
                    psar[i] = high[i - 1]
                if high[i - 2] > psar[i]:
                    psar[i] = high[i - 2]

    return pd.Series(psar)


class Quant_old(object):
    def __init__(self, stocks):
        self.stocks = stocks
    default_qty_type = 'fixed'
    default_qty_value = 10
    initial_capital = 500.
    shorting = False

    def Strategy(self, strat='Double SMA Crossover'):
        change_in_positions, positions, unrealized_wealth, trades, trade = (list() for i in range(5))
        metrics = ['Total # of Trades', 'Return %', 'Percent Wins', 'Win / Loss Ratio', 'Gross Profit',
                   'Gross Loss', 'Net Profit', 'Buy and Hold Return', 'Payout Ratio', 'Average Profit / Trade',
                   'Median Profit / Trade', 'Largest Gain', 'Largest Loss', 'Profit Factor', 'Max Drawdown',
                   'Max Drawdown %', 'Outlier Adj Profit Factor', 'Sharpe Ratio', 'Sortino Ratio',
                   'Max Consecutive Winners', 'Max Consecutive Losers']

        def backtest(stock):
            balance = self.initial_capital
            for i in range(len(stock)):
                close = stock['Close'].iloc[i]

                def entry(qty=self.default_qty_value, long=True, when=True, close_when=True):
                    if long:
                        if when:
                            return qty
                        elif close_when and trade is True:
                            return qty * -1
                        else:
                            return 0
                    else:
                        pass

                # As function iterates over historical data, determine whether to increase or decrease position size
                # based on strategy selected

                if strat == 'Double SMA Crossover':
                    short_sma = simple_moving_avg(stock, length=10)
                    long_sma = simple_moving_avg(stock, length=20)
                    positions.append(entry(when=(short_sma.iloc[i] > long_sma.iloc[i]),
                                     close_when=(long_sma.iloc[i] <= short_sma.iloc[i])))

                if strat == 'Ichimoku':
                    disp = 26
                    ichi_cloud = ichimoku(stock, displ=disp)
                    rsi = rel_strength_index(stock).iloc[i]

                    lead_1 = ichi_cloud['Lead 1']
                    lead_2 = ichi_cloud['Lead 2']
                    conversion = ichi_cloud['Conversion Line'].iloc[i]
                    base = ichi_cloud['Base Line'].iloc[i]
                    lagging = ichi_cloud['Lagging']

                    # price is above the cloud
                    rule_1 = (close > max(lead_1.iloc[i], lead_2.iloc[i]))
                    # 'TK Crossover' - conversion line crosses over base line
                    rule_2 = (conversion > base)
                    # cloud ahead must be bullish cloud - lead 1 is over lead 2
                    rule_3 = (lead_1.iloc[i] > lead_2.iloc[i])
                    # Lagging span is greater than the cloud
                    rule_4 = (lagging.iloc[i - disp] > max(lead_1.iloc[i - disp], lead_2.iloc[i - disp]))

                    # price is below the cloud
                    rule_5 = (close < min(lead_1.iloc[i], lead_2.iloc[i]))
                    # 'TK Crossover' - base line crosses over conversion line
                    rule_6 = (base > conversion)

                    buy_signal = rule_1 and rule_2 and rule_3 and rule_4
                    sell_signal = rule_5 or rule_6

                    positions.append(entry(when=buy_signal, close_when=sell_signal))

                if strat == 'RSI 2':
                    rsi = rel_strength_index(stock, length=2).iloc[i]
                    sma_200 = simple_moving_avg(stock, length=200).iloc[i]
                    sma_10 = simple_moving_avg(stock, length=10).iloc[i]
                    oversold = (rsi < 5)

                    buy_signal = ((close > sma_200) and oversold)
                    sell_signal = (close > sma_10)
                    positions.append(entry(when=buy_signal, close_when=sell_signal))

                if strat == 'PSAR & MACD':
                    macd = MACD(stock)['Hist'].iloc[i]
                    psar = p_sar(stock, accel=0.01).iloc[i]

                    # MACD crossover
                    rule_1 = (macd > 0)
                    # parabolic sar is below price
                    rule_2 = (psar < close)

                    buy_signal = rule_1 and rule_2
                    sell_signal = (not rule_1) and (not rule_2)
                    positions.append(entry(when=buy_signal, close_when=sell_signal))

                current_pos = positions[-1]
                if i == 0:
                    # if strategy needs to increase position size immediately,
                    # then the change in shares is the difference between the position size and 0
                    change = current_pos - 0
                else:
                    # otherwise determine the change in shares from the previous position
                    change = current_pos - positions[-2]

                change_in_positions.append(change)
                balance -= (change * close)
                unrealized_wealth.append(balance + (current_pos * close))

            portfolio = pd.DataFrame({'Date': stock['Date'], 'Close': stock['Close'],
                                      'Unrealized Wealth': unrealized_wealth, 'Balance': balance, 'Position': positions,
                                      'Change in Position': change_in_positions})
            portfolio['Returns'] = portfolio['Unrealized Wealth'].pct_change()
            # plt.plot(portfolio['Unrealized Wealth'])
            # plt.show()

            def return_trades(df):
                for y in range(len(df)):
                    pos_change = df['Change in Position'].iloc[y]
                    if pos_change != 0:
                        # log changes in position size to list "trade".
                        # If closing out a trade, append trade to trades list and start over
                        trade.append([df['Date'].iloc[y], df['Close'].iloc[y], df['Position'].iloc[y],
                                      df['Change in Position'].iloc[y], df['Unrealized Wealth'].iloc[y]])
                        if df['Position'].iloc[y] == 0:
                            profit = trade[-1][4] - trade[0][4]
                            trade.append(profit)
                            trade.append(profit / trade[0][4])
                            trades.append(deepcopy(trade))
                            trade.clear()
                return trades

            def analysis(trade_lst, risk_free_rate=0.0005):
                def profits():
                    lst = list()
                    for j in trade_lst:
                        lst.append(j[2])
                    return lst
                profits_ser = pd.Series(profits())
                profits_lst = profits()
                pnl = portfolio['Unrealized Wealth']

                def portfolio_return_pct():
                    return (pnl.iloc[-1] - pnl.iloc[0]) / pnl.iloc[0]

                def total_trades():
                    # number of trades executed
                    return profits_ser.count()

                def pct_win():
                    # % of profitable trades out of the total number of trades
                    win_count = profits_ser[lambda x: x > 0].count()
                    return win_count / len(profits_ser)

                def win_loss_ratio():
                    # How many profitable trades per one losing trade
                    return profits_ser[lambda x: x > 0].count() / profits_ser[lambda x: x < 0].count()

                def payout_ratio():
                    # average profit / average loss
                    avg_win = profits_ser[lambda x: x > 0].mean()
                    avg_loss = profits_ser[lambda x: x < 0].mean()
                    return avg_win / abs(avg_loss)

                def buy_and_hold():
                    return (stock['Close'].iloc[-1] * self.default_qty_value) - \
                           (stock['Close'].iloc[0] * self.default_qty_value)

                def gross_profit():
                    return profits_ser[lambda x: x > 0].sum()

                def gross_loss():
                    return profits_ser[lambda x: x <= 0].sum()

                def net_profit():
                    return gross_profit() + gross_loss()

                def avg_profit_trade():
                    return profits_ser.mean()

                def median_profit_trade():
                    return profits_ser.median()

                def largest_loss():
                    return profits_ser.min()

                def largest_gain():
                    return profits_ser.max()

                def profit_factor():
                    # gross profit / gross loss
                    # For every $1 invested, you can expect $x back
                    return gross_profit() / abs(gross_loss())

                def outlier_adj_pf(top=1):
                    # same concept as profit factor, but excluding the most extreme profitable value
                    if top == 0:
                        sorted_profits = profits_ser.sort_values()
                    else:
                        sorted_profits = profits_ser.sort_values()[:(-1 * top)]
                    return sorted_profits[lambda x: x > 0].sum() / abs(sorted_profits[lambda x: x <= 0].sum())

                def streaks(winners=True):
                    streak = 0
                    all_streaks = list()
                    for x in profits_lst:
                        if winners:
                            if x > 0:
                                streak += 1
                            else:
                                all_streaks.append(streak)
                                streak = 0
                        else:
                            if x < 0:
                                streak += 1
                            else:
                                all_streaks.append(streak)
                                streak = 0
                    return max(all_streaks) if (max(all_streaks) > 1) else 0

                def max_drawdown(percentage=True):
                    # maximum loss from peak to a trough in a portfolio
                    # can be expressed in percentage or dollar terms
                    mdd = 0
                    peak = pnl[0]
                    for x in range(1, len(pnl)):
                        if pnl.iloc[x] > peak:
                            peak = pnl.iloc[x]
                        if percentage:
                            dd = (peak - pnl.iloc[x]) / peak
                        else:
                            dd = peak - pnl.iloc[x]
                        if dd > mdd:
                            mdd = dd
                    return mdd

                def sharpe_ratio():
                    # (portfolio return - risk free return) / st dev of portfolio
                    # Risk free rate as of 2019 = 0.05 %
                    excess_returns = portfolio['Returns'] - risk_free_rate
                    return excess_returns.mean() / excess_returns.std()

                def sortino_ratio():
                    # (portfolio return - risk free rate) / portfolio downside st dev
                    excess_returns = portfolio['Returns'] - risk_free_rate
                    return excess_returns.mean() / excess_returns[lambda x: x < 0].std()

                specs = [total_trades(), portfolio_return_pct(), pct_win(), win_loss_ratio(), gross_profit(),
                         gross_loss(), net_profit(), buy_and_hold(), payout_ratio(), avg_profit_trade(), median_profit_trade(),
                         largest_gain(), largest_loss(), profit_factor(), max_drawdown(percentage=False), max_drawdown(),
                         outlier_adj_pf(), sharpe_ratio(), sortino_ratio(), streaks(), streaks(winners=False)]

                return pd.DataFrame(specs, columns=[strat], index=metrics)

            return analysis(return_trades(portfolio))

        performance = pd.DataFrame(index=metrics)
        for ticker in self.stocks:
            performance[ticker] = backtest(self.stocks[ticker])

        return performance


# Class Quant requires only the input of a ticker as a string
# Default settings can be tweaked by referencing the various keywords

# yfinance module is used to pull historical data. The pull can be adjusted by changing the "period" and "interval" class variables

# "bars_back" trims the raw data by pulling the most recent x number of ticks. I can explain later why we need this

# "initial capital" is how much cash we want the Quant to work with

# "default_qty_type" does not have any functionality yet, however in the future it should allow the following options:
#       if type = 'fixed', the value in the variable default_qty_val represents # of shares
#       if type = 'cash', the value in the variable default_qty_val represents $
#       if type = 'pct_of_equity', the value in the variable default_qty_val represents a % of however much cash the strategy has at the time

# "pyramiding" indicates how many moves in the same direction can be made (i.e. increasing a long position)

# if "shorting" is set to true, this will allow the strategy to short stocks - this should work but has not been tested

class Quant(object):
    def __init__(self, ticker, period='6mo', interval='1h', bars_back=500, default_qty_type='fixed',
                 default_qty_val=10, initial_capital=1000, pyrmaiding=1, shorting=False):
        self.bars_back = bars_back
        self.interval = interval
        self.period = period
        self.pyrmaiding = pyrmaiding
        self.ticker = ticker
        self.initial_capital = initial_capital
        self.default_qty_val = default_qty_val
        self.default_qty_type = default_qty_type
        self.adds_to_position = 0
        self.shorting = shorting
        self.df = yf.download(ticker, period=period, interval=interval).reset_index()

    def algo(self):
        # the algo function is what triggers the strategy. I'm pretty sure this is unnecessary
        order_queue, unrealized_wealth, trades, positions, pos_change = (list() for i in range(5))

        # An OpenOrder object is created whenever the criteria for an order is met
        class OpenOrder(object):
            # An order that specifies a limit or stop becomes a limit order or a stop order respectively - should work, not tested yet
            def __init__(self, tag, date, qty, buy=True, limit=0, stop=0):
                self.date = date
                self.tag = tag
                self.buy = buy
                self.stop = stop
                self.limit = limit
                self.qty = qty
                self.canceled = False

            def execute_order(self, p):
                # this function is called to see if the conditions for executing the order has been met. If so, returns true
                # if the order is a market order (i.e. not a limit or stop order), this will always return true
                if self.buy:
                    if self.limit != 0 and self.stop == 0:
                        # if it is a limit order, price must be below limit to be converted to market order
                        if p <= self.limit:
                            return True
                        else:
                            return False
                    elif self.limit == 0 and self.stop != 0:
                        # if it is a stop order, price must reach stop to be converted to market order
                        if p >= self.stop:
                            return True
                        else:
                            return False
                    elif self.limit != 0 and self.stop != 0:
                        # if it is a stop-limit order, price must reach stop and be below limit to be converted to market order
                        if self.limit >= p >= self.stop:
                            return True
                        else:
                            return False
                    else:
                        return True
                else:
                    if self.limit != 0 and self.stop == 0:
                        # if it is a limit order, price must be below limit to be converted to market order
                        if p >= self.limit:
                            return True
                        else:
                            return False
                    elif self.limit == 0 and self.stop != 0:
                        # if it is a stop order, price must reach stop to be converted to market order
                        if p <= self.stop:
                            return True
                        else:
                            return False
                    elif self.limit != 0 and self.stop != 0:
                        # if it is a stop-limit order, price must reach stop and be below limit to be converted to market order
                        if self.stop >= p >= self.limit:
                            return True
                        else:
                            return False
                    else:
                        return True

        # A FilledOrder object is created when an OpenOrder object executes the order. Simply logs information. Might be unnecessary, could be a dict
        class FilledOrder(object):
            def __init__(self, date, close, long, shares):
                self.shares = shares
                self.long = long
                self.close = close
                self.date = date

        def entry(order, when=True, cancel_when=False):
            if cancel_when:
                # specify criteria for canceling an order (i.e. too much time has passed since the order has been placed)
                order.canceled = True
            if when:
                # if the criteria for initiating an order has been met
                if order.buy and self.adds_to_position != self.pyrmaiding:
                    # if the order is to buy, and the number of moves in a position does not yet equal the pyramiding limit, add the order to the queue
                    order_queue.append(order)
                    self.adds_to_position += 1
                elif self.shorting:
                    # if shorting is allowed, if the order is to sell, and the number of moves in a position does not yet equal the pyramiding limit, add the order to the queue
                    if order.buy is False and self.adds_to_position != (self.pyrmaiding * -1):
                        order_queue.append(order)
                        self.adds_to_position -= 1
                else:
                    if order.buy is False and self.adds_to_position != 0:
                        # if the order is to sell, and shorting is not allowed, and we own stock, add the order to the queue
                        # NOTE, this needs to be updated. This does not account for selling more than we own (i.e. shorting even though shorting shouldn't be allowed in this case)
                        order_queue.append(order)
                        self.adds_to_position -= 1

        def trim(df):
            # trims the historical data by however many bars_back is specified in the class variable
            return df.iloc[len(self.df) - self.bars_back:].reset_index(drop=True)

        def double_sma_crossover():
            # this is a very basic strategy
            hist = trim(self.df)

            # initialize technical indicators we are going to use in our strategy
            fast_sma = trim(simple_moving_avg(self.df, length=20))
            slow_sma = trim(simple_moving_avg(self.df, length=100))

            position = 0
            balance = self.initial_capital

            for i in range(len(hist)):
                # this for loop starts iterating over every tick, buying or selling based on the criteria below
                close = hist['Close'].iloc[i]
                date = hist['Date'].iloc[i]

                # buy when fast sma crosses over the slow sma
                # sell when slow sma crosses over the fast sma
                entry(OpenOrder('order1', date, self.default_qty_val), when=(fast_sma.iloc[i] > slow_sma.iloc[i]))
                entry(OpenOrder('order1', date, self.default_qty_val, buy=False), when=(slow_sma.iloc[i] >= fast_sma.iloc[i]))

                change = 0
                for order in order_queue:
                    if order.canceled:
                        # if the order has been canceled, remove the order from the queue
                        order_queue.remove(order)
                    else:
                        if order.execute_order(close):
                            # if the order meets the criteria to actually be executed, add the filled order to the trades list and remove the open order form the queue
                            filled_order = FilledOrder(date, close, order.buy, order.qty)

                            trades.append(filled_order)
                            order_queue.remove(order)

                            # change variable shows the change in shares compared to the previous tick
                            change += filled_order.shares if filled_order.long else (filled_order.shares * -1)

                    # update tracking metrics
                    position += change
                    balance -= change * close

                pos_change.append(change)
                positions.append(position)
                # unrealized wealth basically shows how your initial capital changed over every tick in the historical data
                # this is changed by however many shares are owned at the time, and the price action
                unrealized_wealth.append(balance + (position * close))

            plt.plot(unrealized_wealth)
            plt.show()

        double_sma_crossover()


test = Quant('MSFT')
test.algo()

